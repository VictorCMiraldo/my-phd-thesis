# 00 extra-ops

M.clj performed extra operations by refactoring imports;
hdiff did produce a correct merge, but it read:

```clojure
(ns metabase.driver.generic-sql
  (:require ...
            [metabase.sync-database.analyze :as analyze]
            [metabase.util.honeysql-extensions :as hx]
            [metabase.util.ssh :as ssh])
  ... )
```

Whereas the committed file reads:

```clojure
(ns metabase.driver.generic-sql
  (:require ...
            [metabase.util
             [honeysql-extensions :as hx]
             [ssh :as ssh]])
  ... )
```

## 01 extra-ops

Again, M.py performed more actions. The committed resolution introduced
an equality operator:

```py
...
if holes and default is not None:
    int_expr.extend(holes)
    if targetcond == True:
        return [(h[0], h[1], None) for h in holes]
...
```

whereas hdiff produced the expected result:

```py
if holes and default is not None:
    int_expr.extend(holes)
    if targetcond is True:
        return [(h[0], h[1], None) for h in holes]
...
```

## 02 insertion-order

This one is weird; the human produced M.java makes sense, the hdiff result
is correct but I can't explain. Hdiff inserted functions in a different order.

## 03 ignoring-change

This is interesting; the human merge did /not/ include a change.

         A.py                          O.py                       B.py
...                         | ...                         | ...                         |
MINOR_VERSION = 89          | MINOR_VERSION = 88          | MINOR_VERSION = 88          |
PATCH_VERSION = '0.dev0'    | PATCH_VERSION = '0.dev0'    | PATCH_VERSION = '0'         |

Yet, M.py is equal to A.py, showing that the developer ignored
the change to PATCH_VERSION; either on purpose or not, but hdiff did produce
the expected result.

## 04 exrta-ops

Once again, M.clj ignored an insertion from A.clj; namelly,

```clj
(assoc-in [:task-name->id (:id args)] (:task-name->id args))
```

Did not get inserted in the final merge; hdiff did consider this insertion.

## 05 insertion-order extra-ops

This one is also a bit weird; with a deletion and insertion following
each other, apparently hdiff can swap orders. I think its because
we swap the arguments on mergePhase1 on one of the deletion cases.
Nevertheless, the patch produced by hdiff makes sense and moreover,
the human did insert more statements on the merge commit.

## 06 ignornig-change

One replica reordered imports, the merge ignored this. We
produced a correct merge with hdiff

## 07 ignoring-change

Human merge did /not/ insert a statement; hdiff again produced 
an expected result.

## 08 extra-ops

This is a fun one! the merge looked something like:

         A.lua                         O.lua                      B.lua
...                         | ...                             | ...                         
dict={name='A',sheet='a'    | dict={name='A',sheet='dir/a'    | dict={name='A',sheet='dir/a'  
     ,name='B',sheet='b'    |      ,name='B',sheet='dir/b'    |      ,name='B',sheet='dir/b'  
                            |                                 | +    ,name='C',sheet='dir/c'
     ,name='D',sheet='d'}   |      ,name='D',sheet='dir/d'}   |      ,name='D',sheet='dir/d'} 

Naturally, the human merge was:

```lua
dict={name='A',sheet='a' 
     ,name='B',sheet='b' 
     ,name='C',sheet='c'
     ,name='D',sheet='d'}
```

But we had no way of doing that. Our merge was:


```lua
dict={name='A',sheet='a' 
     ,name='B',sheet='b' 
     ,name='C',sheet='dir/c'
     ,name='D',sheet='d'}
```

I'd argue our mage still constitutes a correct result.

## 09 extra-ops

Import reordering; hdiff still produced a correct result. The human merge
permuted the insertions.
